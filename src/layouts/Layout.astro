---
import '../../src/styles/globals.css';
import '@fontsource-variable/inter/wght.css';
import interWoff2 from '@fontsource-variable/inter/files/inter-latin-wght-normal.woff2?url';
import Header from '../components/Header.astro';
import Footer from '../components/Footer.astro';
import AdminInactivityTimeout from '../components/AdminInactivityTimeout.astro';
import { getStore } from '@netlify/blobs';
import { extractUserFromSession } from '../utils/discord-webhook';

interface Props {
    title: string;
    description?: string;
    isAdmin?: boolean;
}

interface MusicPlaylistItem {
    id: string;
    title: string;
}

interface ThemeSettings {
    activeTheme: 'christmas' | 'halloween' | 'default' | 'new-year';
    christmasMusic: string;
    halloweenMusic: string;
    defaultMusic: string;
    newYearMusic: string;
    defaultMusicPlaylist?: MusicPlaylistItem[];
    christmasMusicPlaylist?: MusicPlaylistItem[];
    halloweenMusicPlaylist?: MusicPlaylistItem[];
    newYearMusicPlaylist?: MusicPlaylistItem[];
}

interface SiteInfo {
    name: string;
    shortName: string;
    version: string;
    owner: string;
    siteUrl: string;
    color: number;
    maintenanceMode?: boolean;
}

const defaultThemeSettings: ThemeSettings = {
    activeTheme: 'default',
    christmasMusic: 'yXfWUNl1PbM',
    halloweenMusic: 'qw07ZfxeV4g',
    defaultMusic: 'lY2yjAdbvdQ',
    newYearMusic: 'MmC4BLodWDk',
    // Default theme playlist - songs from Spotify Pop Mix playlist
    defaultMusicPlaylist: [
        { id: 'lY2yjAdbvdQ', title: 'Treat You Better - Shawn Mendes' },
        { id: 'JGwWNGJdvx8', title: 'Shape of You - Ed Sheeran' },
        { id: '4NRXx6U8ABQ', title: 'Blinding Lights - The Weeknd' },
        { id: 'ic8j13piAhQ', title: 'Cruel Summer - Taylor Swift' },
        { id: 'kPa7bsKwL-c', title: 'Die With A Smile - Lady Gaga, Bruno Mars' },
        { id: 'hT_nvWreIhg', title: 'Counting Stars - OneRepublic' },
        { id: 'G7KNmW9a75Y', title: 'Flowers - Miley Cyrus' },
        { id: 'vkQ06Y9rg7A', title: 'Sorry - Justin Bieber' },
        { id: 'QYh6mYIJG2Y', title: '7 rings - Ariana Grande' },
        { id: 'tD4HCZe-tew', title: 'Lush Life - Zara Larsson' },
        { id: 'V9PVRfjEBTI', title: 'BIRDS OF A FEATHER - Billie Eilish' },
        { id: 'PMivT7MJ41M', title: "That's What I Like - Bruno Mars" },
        { id: 'H5v3kku4y6Q', title: 'As It Was - Harry Styles' },
        { id: 'oygrmJFKYZY', title: "Don't Start Now - Dua Lipa" },
        { id: 'PT2_F-1esPk', title: 'Closer - The Chainsmokers ft. Halsey' },
        { id: 'xpVfcZ0ZcFM', title: "There's Nothing Holdin' Me Back - Shawn Mendes" },
        { id: 'NmugSMBh_iI', title: 'Maps - Maroon 5' },
        { id: 'ZmDBbnmKpqQ', title: 'Without Me - Halsey' },
        { id: 'nSDgHBxUbVQ', title: 'Photograph - Ed Sheeran' },
        { id: 'nfs8NYg7yQM', title: 'Attention - Charlie Puth' },
        { id: 'e-ORhEE9VVg', title: 'Blank Space - Taylor Swift' },
        { id: 'LMOKlXfXn50', title: 'Save Your Tears (Remix) - The Weeknd, Ariana Grande' },
        { id: 'LOZuxwVk7TU', title: 'Toxic - Britney Spears' },
        { id: 'M11SvDtPBhA', title: 'Party In The U.S.A. - Miley Cyrus' },
        { id: 'Vzo-EL_62fQ', title: 'Ghost - Justin Bieber' },
        { id: 'eVli-tstM5E', title: 'Espresso - Sabrina Carpenter' },
        { id: 'KEG7b851Ric', title: 'Taste - Sabrina Carpenter' },
        { id: 'bVeTqsJU7c4', title: "we can't be friends - Ariana Grande" },
        { id: 'bpOSxM0rNPM', title: 'Poker Face - Lady Gaga' }
    ]
};

// Fetch theme settings from Netlify Blobs on the server
async function getThemeSettings(): Promise<ThemeSettings> {
    try {
        const store = getStore({ name: 'theme-settings', consistency: 'strong' });
        const data = await store.get('settings', { type: 'json' });
        if (data) {
            return data as ThemeSettings;
        }
        return defaultThemeSettings;
    } catch (error) {
        console.error('Error fetching theme settings:', error);
        return defaultThemeSettings;
    }
}

// Fetch site info for maintenance mode check
async function getSiteInfo(): Promise<SiteInfo | null> {
    try {
        const store = getStore({ name: 'site-info', consistency: 'strong' });
        const data = await store.get('settings', { type: 'json' });
        if (data) {
            return data as SiteInfo;
        }
        return null;
    } catch (error) {
        console.error('Error fetching site info:', error);
        return null;
    }
}

const { title, description = 'Del Perro Police Department - Officer Resources and Information', isAdmin = false } = Astro.props;

// Check maintenance mode and user authentication
const siteInfo = await getSiteInfo();
const isMaintenanceMode = siteInfo?.maintenanceMode || false;

// Check if user is logged in (admin)
let isUserAdmin = false;
if (isMaintenanceMode) {
    try {
        const user = await extractUserFromSession(Astro.request);
        isUserAdmin = !!user;
    } catch {
        isUserAdmin = false;
    }
}

// Redirect to maintenance page if in maintenance mode and user is not admin
// Skip redirect for admin pages (login, etc.) and the maintenance page itself
const currentPath = new URL(Astro.request.url).pathname;
const isMaintenancePage = currentPath === '/maintenance';
const isAdminPath = currentPath.startsWith('/admin');
const isApiPath = currentPath.startsWith('/api');

if (isMaintenanceMode && !isUserAdmin && !isMaintenancePage && !isAdminPath && !isApiPath) {
    return Astro.redirect('/maintenance');
}

// Get the site URL for OG tags
const siteUrl = Astro.url.origin || 'https://delperro.netlify.app';
const ogImage = `${siteUrl}/images/DPPD_Seal_3.png`;

// Fetch theme settings server-side so everyone sees the same theme
const themeSettings = await getThemeSettings();
const activeTheme = themeSettings.activeTheme;
const bodyClass = `antialiased text-white theme-${activeTheme}`;

// Get the correct music ID for the active theme
const musicIds = {
    christmas: themeSettings.christmasMusic,
    halloween: themeSettings.halloweenMusic,
    default: themeSettings.defaultMusic,
    'new-year': themeSettings.newYearMusic || 'MmC4BLodWDk'
};
const activeMusicId = musicIds[activeTheme];

// Get the playlist for the active theme (if available)
const playlists = {
    christmas: themeSettings.christmasMusicPlaylist,
    halloween: themeSettings.halloweenMusicPlaylist,
    default: themeSettings.defaultMusicPlaylist || defaultThemeSettings.defaultMusicPlaylist,
    'new-year': themeSettings.newYearMusicPlaylist
};
const activePlaylist = playlists[activeTheme] || [];
const playlistJson = JSON.stringify(activePlaylist);

// Theme-specific styling for music player (server-rendered)
const themePlayerStyles = {
    christmas: {
        playerClass: 'bg-red-800/90 border-yellow-500',
        buttonClass: 'bg-green-700/50 hover:text-green-300',
        musicTitle: 'üéÑDel Perro PD - Christmas Music'
    },
    halloween: {
        playerClass: 'bg-purple-900/90 border-orange-500',
        buttonClass: 'bg-orange-700/50 hover:text-orange-300',
        musicTitle: 'üëª Del Perro PD - Spooky Music'
    },
    default: {
        playerClass: 'bg-blue-800/90 border-blue-400',
        buttonClass: 'bg-blue-700/50 hover:text-blue-300',
        musicTitle: 'üõ°Ô∏è Del Perro PD - Music'
    },
    'new-year': {
        playerClass: 'bg-black/90 border-yellow-400',
        buttonClass: 'bg-yellow-600/50 hover:text-yellow-300',
        musicTitle: 'üéÜ New Year 2026 Celebration'
    }
};
const playerStyle = themePlayerStyles[activeTheme];
---

<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <title>{title}</title>
        <meta name="viewport" content="width=device-width" />
        <meta name="description" content={description} />
        <meta name="generator" content={Astro.generator} />
        <meta name="author" content="taz_elite" />
        <link rel="icon" type="image/png" href="/images/DPPD_Seal_3.png" />
        <link rel="preload" as="font" type="font/woff2" href={interWoff2} crossorigin />

        <!-- Open Graph / Facebook -->
        <meta property="og:type" content="website" />
        <meta property="og:url" content={Astro.url.href} />
        <meta property="og:title" content={title} />
        <meta property="og:description" content={`${description} | Created by: taz_elite`} />
        <meta property="og:image" content={ogImage} />
        <meta property="og:site_name" content="Del Perro Police Department" />

        <!-- Twitter -->
        <meta name="twitter:card" content="summary_large_image" />
        <meta name="twitter:url" content={Astro.url.href} />
        <meta name="twitter:title" content={title} />
        <meta name="twitter:description" content={`${description} | Created by: taz_elite`} />
        <meta name="twitter:image" content={ogImage} />

        <!-- Discord specific -->
        <meta name="theme-color" content="#1e40af" />
    </head>
    <body class={bodyClass} data-theme={activeTheme} data-music-id={activeMusicId} data-playlist={playlistJson}>
        <!-- Falling effects container -->
        <div id="effects-container" class="fixed inset-0 pointer-events-none z-[9999] overflow-hidden"></div>

        <!-- New Year Countdown Timer (only shown for new-year theme) -->
        <div id="countdown-container" class={`countdown-container ${activeTheme !== 'new-year' ? 'hidden' : ''}`}>
            <div id="countdown-title" class="countdown-title">üéÜ Countdown to 2026 üéÜ</div>
            <div id="countdown-timer" class="countdown-timer">
                <div class="countdown-unit">
                    <div id="countdown-days" class="countdown-value">00</div>
                    <div class="countdown-label">Days</div>
                </div>
                <div class="countdown-unit">
                    <div id="countdown-hours" class="countdown-value">00</div>
                    <div class="countdown-label">Hours</div>
                </div>
                <div class="countdown-unit">
                    <div id="countdown-minutes" class="countdown-value">00</div>
                    <div class="countdown-label">Minutes</div>
                </div>
                <div class="countdown-unit">
                    <div id="countdown-seconds" class="countdown-value">00</div>
                    <div class="countdown-label">Seconds</div>
                </div>
            </div>
        </div>

        <!-- Theme Effects Script - Uses server-provided theme -->
        <script>
            // Falling Effects Toggle
            const EFFECTS_VISIBLE_KEY = 'dppd-effects-visible';

            // Get saved effects visibility preference (default to visible/true)
            function getEffectsVisible() {
                const saved = localStorage.getItem(EFFECTS_VISIBLE_KEY);
                if (saved === null) return true; // Default to showing effects
                return saved === 'true';
            }

            // Save effects visibility preference
            function setEffectsVisible(visible) {
                localStorage.setItem(EFFECTS_VISIBLE_KEY, visible.toString());
            }

            // Update effects container visibility and button text
            function updateEffectsVisibility(visible) {
                const container = document.getElementById('effects-container');
                const toggleText = document.getElementById('effects-toggle-text');

                if (container) {
                    container.style.display = visible ? 'block' : 'none';
                }
                if (toggleText) {
                    toggleText.textContent = visible ? 'Hide Effects' : 'Show Effects';
                }
            }

            // Initialize effects toggle on page load
            function initEffectsToggle() {
                const effectsVisible = getEffectsVisible();
                updateEffectsVisibility(effectsVisible);

                const toggleButton = document.getElementById('effects-toggle');
                if (toggleButton) {
                    toggleButton.addEventListener('click', () => {
                        const currentlyVisible = getEffectsVisible();
                        const newVisible = !currentlyVisible;
                        setEffectsVisible(newVisible);
                        updateEffectsVisibility(newVisible);
                    });
                }
            }

            // Run initialization
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', initEffectsToggle);
            } else {
                initEffectsToggle();
            }
        </script>

        <script>
            // Theme configuration
            const themeConfig = {
                christmas: {
                    class: 'theme-christmas',
                    musicTitle: 'üéÑDel Perro PD - Christmas Music',
                    playerStyle: 'bg-red-800/90 border-yellow-500',
                    buttonStyle: 'bg-green-700/50 hover:text-green-300',
                    symbols: ['‚ùÑ', '‚ùÖ', '‚ùÜ', '‚úª', '‚úº', '‚ùâ']
                },
                halloween: {
                    class: 'theme-halloween',
                    musicTitle: 'üëª Del Perro PD - Spooky Music',
                    playerStyle: 'bg-purple-900/90 border-orange-500',
                    buttonStyle: 'bg-orange-700/50 hover:text-orange-300',
                    symbols: ['üíÄ', 'üéÉ', 'üßü', 'üëª', 'ü¶á', 'üï∑Ô∏è']
                },
                default: {
                    class: 'theme-default',
                    musicTitle: 'üõ°Ô∏è Del Perro PD - Music',
                    playerStyle: 'bg-blue-800/90 border-blue-400',
                    buttonStyle: 'bg-blue-700/50 hover:text-blue-300',
                    symbols: []
                },
                'new-year': {
                    class: 'theme-new-year',
                    musicTitle: 'üéÜ New Year 2026 Celebration',
                    playerStyle: 'bg-black/90 border-yellow-400',
                    buttonStyle: 'bg-yellow-600/50 hover:text-yellow-300',
                    symbols: ['üéâ', 'üéä', '‚ú®', '‚≠ê', 'üåü', 'üí´'],
                    confetti: ['üéâ', 'üéä', 'ü•≥', 'üéá', 'üéÜ', '‚ú®', '‚≠ê', 'üíõ', 'üß°', 'üíú'],
                    years: ['2025', '2026']
                }
            };

            // Get theme from server-rendered data attribute (no API fetch needed)
            const currentTheme = document.body.dataset.theme || 'christmas';
            const musicId = document.body.dataset.musicId;

            // Parse playlist from data attribute
            let playlist = [];
            try {
                const playlistData = document.body.dataset.playlist;
                if (playlistData) {
                    playlist = JSON.parse(playlistData);
                }
            } catch (e) {
                console.error('Error parsing playlist:', e);
            }

            let currentSongIndex = 0;
            let player = null;
            let isPlaying = false;
            let shouldStayPaused = false; // Flag to enforce paused state after seekTo

            // Storage key for music state persistence
            const MUSIC_STATE_KEY = 'dppd-music-state';

            // Track if user has ever interacted with music (to distinguish first visit from returning)
            const MUSIC_VISITED_KEY = 'dppd-music-visited';

            // Get saved music state from localStorage
            function getSavedMusicState() {
                try {
                    const saved = localStorage.getItem(MUSIC_STATE_KEY);
                    if (saved) {
                        const state = JSON.parse(saved);
                        // Only restore if the same theme is active
                        if (state.theme === currentTheme) {
                            return state;
                        }
                    }
                } catch (e) {
                    console.error('Error reading music state:', e);
                }
                return null;
            }

            // Check if user has visited before (to know if we should auto-play on first visit)
            function hasVisitedBefore() {
                return localStorage.getItem(MUSIC_VISITED_KEY) === 'true';
            }

            // Mark that user has visited
            function markAsVisited() {
                localStorage.setItem(MUSIC_VISITED_KEY, 'true');
            }

            // Save music state to localStorage
            function saveMusicState() {
                if (player && typeof player.getCurrentTime === 'function') {
                    try {
                        const state = {
                            theme: currentTheme,
                            musicId: getCurrentMusicId(),
                            songIndex: currentSongIndex,
                            isPlaying: isPlaying,
                            currentTime: player.getCurrentTime(),
                            timestamp: Date.now()
                        };
                        localStorage.setItem(MUSIC_STATE_KEY, JSON.stringify(state));
                    } catch (e) {
                        console.error('Error saving music state:', e);
                    }
                }
            }

            // Get current music ID (from playlist or single ID)
            function getCurrentMusicId() {
                if (playlist && playlist.length > 0 && currentSongIndex < playlist.length) {
                    return playlist[currentSongIndex].id;
                }
                return musicId;
            }

            // Get current song title
            function getCurrentSongTitle() {
                if (playlist && playlist.length > 0 && currentSongIndex < playlist.length) {
                    return playlist[currentSongIndex].title;
                }
                const config = themeConfig[currentTheme] || themeConfig.christmas;
                return config.musicTitle;
            }

            // Update song title display
            function updateSongTitle() {
                const musicTitle = document.getElementById('yt-song-title');
                const songCounter = document.getElementById('yt-song-counter');
                if (playlist && playlist.length > 0) {
                    if (musicTitle) {
                        musicTitle.textContent = getCurrentSongTitle();
                    }
                    if (songCounter) {
                        songCounter.textContent = `${currentSongIndex + 1}/${playlist.length}`;
                        songCounter.classList.remove('hidden');
                    }
                } else {
                    if (songCounter) {
                        songCounter.classList.add('hidden');
                    }
                }
            }

            // Change to a specific song
            function changeSong(index) {
                if (!playlist || playlist.length === 0) return;
                if (index < 0) index = playlist.length - 1;
                if (index >= playlist.length) index = 0;

                currentSongIndex = index;
                const newMusicId = playlist[currentSongIndex].id;

                if (player && typeof player.loadVideoById === 'function') {
                    player.loadVideoById(newMusicId);
                    updateSongTitle();
                    saveMusicState();
                }
            }

            // Play next song
            function nextSong() {
                changeSong(currentSongIndex + 1);
            }

            // Play previous song
            function prevSong() {
                changeSong(currentSongIndex - 1);
            }

            // Save state before page unload (navigation)
            window.addEventListener('beforeunload', saveMusicState);
            // Also save periodically in case of unexpected closure
            setInterval(saveMusicState, 2000);

            // Apply theme styling to music player
            function applyThemeStyling() {
                const config = themeConfig[currentTheme] || themeConfig.christmas;

                // Update music player styling
                const musicPlayer = document.getElementById('youtube-music-player');
                if (musicPlayer) {
                    // Remove old style classes
                    musicPlayer.classList.remove(
                        'bg-red-800/90', 'border-yellow-500',
                        'bg-purple-900/90', 'border-orange-500',
                        'bg-blue-800/90', 'border-blue-400',
                        'bg-black/90', 'border-yellow-400'
                    );
                    // Add new style classes
                    config.playerStyle.split(' ').forEach(cls => musicPlayer.classList.add(cls));
                }

                // Apply style to all player buttons (play, prev, next)
                const buttonIds = ['yt-music-toggle', 'yt-prev-btn', 'yt-next-btn'];
                buttonIds.forEach(id => {
                    const button = document.getElementById(id);
                    if (button) {
                        // Remove old button style classes
                        button.classList.remove(
                            'bg-green-700/50', 'hover:text-green-300',
                            'bg-orange-700/50', 'hover:text-orange-300',
                            'bg-blue-700/50', 'hover:text-blue-300',
                            'bg-yellow-600/50', 'hover:text-yellow-300'
                        );
                        // Add new button style classes
                        config.buttonStyle.split(' ').forEach(cls => button.classList.add(cls));
                    }
                });

                const musicTitle = document.getElementById('yt-song-title');
                if (musicTitle && (!playlist || playlist.length === 0)) {
                    musicTitle.textContent = config.musicTitle;
                }
            }

            // Create falling effects
            function createFallingEffects() {
                const container = document.getElementById('effects-container');
                if (!container) return;

                // Clear existing effects
                container.innerHTML = '';

                const config = themeConfig[currentTheme] || themeConfig.christmas;
                const symbols = config.symbols;

                if (symbols.length === 0) return; // No effects for default theme

                // Special handling for New Year theme
                if (currentTheme === 'new-year') {
                    createNewYearEffects(container, config);
                    return;
                }

                const numberOfElements = 50;

                for (let i = 0; i < numberOfElements; i++) {
                    setTimeout(() => {
                        createFallingElement(container, symbols);
                    }, i * 200);
                }
            }

            // Create New Year specific effects (confetti + years)
            function createNewYearEffects(container, config) {
                const confetti = config.confetti || [];
                const years = config.years || [];

                // Create confetti elements (more of them)
                for (let i = 0; i < 40; i++) {
                    setTimeout(() => {
                        createConfettiElement(container, confetti);
                    }, i * 150);
                }

                // Create year number elements
                for (let i = 0; i < 15; i++) {
                    setTimeout(() => {
                        createYearElement(container, years);
                    }, i * 400);
                }
            }

            // Create confetti element
            function createConfettiElement(container, confetti) {
                const element = document.createElement('div');
                element.className = 'falling-element falling-confetti';
                element.textContent = confetti[Math.floor(Math.random() * confetti.length)];

                // Random starting position
                element.style.left = Math.random() * 100 + 'vw';

                // Random size (smaller for confetti)
                const size = Math.random() * 1 + 0.8;
                element.style.fontSize = size + 'rem';

                // Random opacity
                element.style.opacity = (Math.random() * 0.4 + 0.6).toString();

                // Random animation duration (faster for confetti)
                const fallDuration = Math.random() * 8 + 6;
                const swayDuration = Math.random() * 2 + 1.5;
                element.style.animationDuration = fallDuration + 's, ' + swayDuration + 's';

                container.appendChild(element);

                // Remove and recreate when animation ends
                element.addEventListener('animationend', function() {
                    element.remove();
                    createConfettiElement(container, confetti);
                });
            }

            // Create year element (2025, 2026)
            function createYearElement(container, years) {
                const element = document.createElement('div');
                element.className = 'falling-element falling-year';
                element.textContent = years[Math.floor(Math.random() * years.length)];

                // Random starting position
                element.style.left = Math.random() * 100 + 'vw';

                // Larger size for year numbers
                const size = Math.random() * 1.5 + 1.5;
                element.style.fontSize = size + 'rem';

                // Random color - gold or silver
                const colors = ['#FFD700', '#C0C0C0', '#FFA500', '#FFE555'];
                element.style.color = colors[Math.floor(Math.random() * colors.length)];

                // Higher opacity for years
                element.style.opacity = (Math.random() * 0.3 + 0.7).toString();

                // Slower animation for years
                const fallDuration = Math.random() * 12 + 10;
                const swayDuration = Math.random() * 4 + 3;
                element.style.animationDuration = fallDuration + 's, ' + swayDuration + 's';

                container.appendChild(element);

                // Remove and recreate when animation ends
                element.addEventListener('animationend', function() {
                    element.remove();
                    createYearElement(container, years);
                });
            }

            function createFallingElement(container, symbols) {
                const element = document.createElement('div');
                element.className = 'falling-element';
                element.textContent = symbols[Math.floor(Math.random() * symbols.length)];

                // Random starting position
                element.style.left = Math.random() * 100 + 'vw';

                // Random size
                const size = Math.random() * 1.5 + 0.5;
                element.style.fontSize = size + 'rem';

                // Random opacity
                element.style.opacity = (Math.random() * 0.5 + 0.5).toString();

                // Random animation duration
                const fallDuration = Math.random() * 10 + 8;
                const swayDuration = Math.random() * 3 + 2;
                element.style.animationDuration = fallDuration + 's, ' + swayDuration + 's';

                container.appendChild(element);

                // Remove and recreate when animation ends
                element.addEventListener('animationend', function() {
                    element.remove();
                    createFallingElement(container, symbols);
                });
            }

            // Initialize YouTube player
            function initYouTubePlayer(videoId) {
                if (typeof YT === 'undefined' || typeof YT.Player === 'undefined') {
                    // Wait for API to load
                    setTimeout(() => initYouTubePlayer(videoId), 100);
                    return;
                }

                // Get saved state to restore playback position
                const savedState = getSavedMusicState();

                // If there's a playlist and saved state, restore song index
                if (savedState && playlist && playlist.length > 0) {
                    if (savedState.songIndex !== undefined && savedState.songIndex < playlist.length) {
                        currentSongIndex = savedState.songIndex;
                        videoId = playlist[currentSongIndex].id;
                    }
                } else if (playlist && playlist.length > 0) {
                    // Start with first song in playlist
                    videoId = playlist[0].id;
                }

                player = new YT.Player('youtube-player', {
                    height: '0',
                    width: '0',
                    videoId: videoId,
                    playerVars: {
                        'autoplay': 0,
                        'controls': 0,
                        'loop': 1,
                        'playlist': videoId
                    },
                    events: {
                        'onReady': function(event) {
                            player.setVolume(30);

                            // Mark that user has visited the site
                            markAsVisited();

                            // Update song title for playlist
                            updateSongTitle();

                            // Restore playback position and state if available
                            if (savedState) {
                                // Seek to saved position (account for small time drift)
                                const timeSinceLastSave = (Date.now() - savedState.timestamp) / 1000;
                                let seekTime = savedState.currentTime + timeSinceLastSave;

                                // Get video duration to handle looping
                                const duration = player.getDuration();
                                if (duration > 0) {
                                    seekTime = seekTime % duration; // Handle wrap-around for looping
                                }

                                // Only play if it was playing before navigation
                                if (savedState.isPlaying) {
                                    player.seekTo(seekTime, true);
                                    player.playVideo();
                                } else {
                                    // Music was paused - keep it paused
                                    // Set internal state and update UI immediately
                                    isPlaying = false;
                                    shouldStayPaused = true; // Flag to prevent auto-play from seekTo
                                    updatePlayIcon();
                                    // Seek to position - if it triggers play, onStateChange will pause it
                                    player.seekTo(seekTime, true);
                                    // Also explicitly pause as a fallback
                                    player.pauseVideo();
                                }
                            } else if (!hasVisitedBefore()) {
                                // First visit ever - start playing automatically
                                player.playVideo();
                            } else {
                                // Returning visitor with no saved state (theme changed) - start playing
                                player.playVideo();
                            }
                        },
                        'onStateChange': function(event) {
                            // If we should stay paused but YouTube started playing (from seekTo), pause it again
                            if (shouldStayPaused && event.data === YT.PlayerState.PLAYING) {
                                player.pauseVideo();
                                shouldStayPaused = false; // Only enforce once
                                return;
                            }

                            if (event.data === YT.PlayerState.PLAYING) {
                                isPlaying = true;
                                updatePlayIcon();
                            } else if (event.data === YT.PlayerState.PAUSED) {
                                isPlaying = false;
                                updatePlayIcon();
                            } else if (event.data === YT.PlayerState.ENDED) {
                                // Auto-advance to next song if playlist exists
                                if (playlist && playlist.length > 1) {
                                    nextSong();
                                } else {
                                    isPlaying = false;
                                    updatePlayIcon();
                                }
                            }
                        }
                    }
                });
            }

            function updatePlayIcon() {
                const playIcon = document.getElementById('yt-icon-play');
                const pauseIcon = document.getElementById('yt-icon-pause');
                if (isPlaying) {
                    playIcon?.classList.add('hidden');
                    pauseIcon?.classList.remove('hidden');
                } else {
                    playIcon?.classList.remove('hidden');
                    pauseIcon?.classList.add('hidden');
                }
            }

            // Initialize everything (theme is already applied server-side)
            function initialize() {
                // Apply theme styling to music player elements
                applyThemeStyling();

                // Start falling effects with the server-provided theme
                createFallingEffects();

                // Initialize countdown for New Year theme
                if (currentTheme === 'new-year') {
                    initCountdown();
                }

                // Show/hide prev/next buttons based on playlist availability
                const prevBtn = document.getElementById('yt-prev-btn');
                const nextBtn = document.getElementById('yt-next-btn');
                if (playlist && playlist.length > 1) {
                    prevBtn?.classList.remove('hidden');
                    nextBtn?.classList.remove('hidden');
                } else {
                    prevBtn?.classList.add('hidden');
                    nextBtn?.classList.add('hidden');
                }

                // Initialize YouTube player with the server-provided music ID
                initYouTubePlayer(getCurrentMusicId());
            }

            // New Year Countdown Timer
            function initCountdown() {
                const countdownContainer = document.getElementById('countdown-container');
                if (!countdownContainer) return;

                function updateCountdown() {
                    // Target: January 1, 2026, 00:00:00 CST (UTC-6)
                    const now = new Date();
                    const targetDate = new Date('2026-01-01T00:00:00-06:00');
                    const celebrationEndDate = new Date('2026-01-08T00:00:00-06:00'); // Hide after Jan 7
                    const diff = targetDate - now;

                    // Hide the countdown if celebration period is over
                    if (now > celebrationEndDate) {
                        countdownContainer.classList.add('hidden');
                        return;
                    }

                    countdownContainer.classList.remove('hidden');

                    if (diff <= 0) {
                        // It's New Year!
                        document.getElementById('countdown-title').textContent = 'üéâ HAPPY NEW YEAR 2026! üéâ';
                        document.getElementById('countdown-timer').innerHTML = '<div class="text-4xl text-yellow-400 font-bold animate-pulse">üéÜ Welcome to 2026! üéÜ</div>';
                        return;
                    }

                    const days = Math.floor(diff / (1000 * 60 * 60 * 24));
                    const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
                    const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
                    const seconds = Math.floor((diff % (1000 * 60)) / 1000);

                    document.getElementById('countdown-days').textContent = days.toString().padStart(2, '0');
                    document.getElementById('countdown-hours').textContent = hours.toString().padStart(2, '0');
                    document.getElementById('countdown-minutes').textContent = minutes.toString().padStart(2, '0');
                    document.getElementById('countdown-seconds').textContent = seconds.toString().padStart(2, '0');
                }

                // Update immediately and then every second
                updateCountdown();
                setInterval(updateCountdown, 1000);
            }

            // Load YouTube IFrame API
            const tag = document.createElement('script');
            tag.src = "https://www.youtube.com/iframe_api";
            const firstScriptTag = document.getElementsByTagName('script')[0];
            firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

            // Set up music toggle button
            document.addEventListener('DOMContentLoaded', function() {
                document.getElementById('yt-music-toggle')?.addEventListener('click', () => {
                    if (player) {
                        if (isPlaying) {
                            player.pauseVideo();
                        } else {
                            player.playVideo();
                        }
                    }
                });

                // Set up prev/next buttons for playlist
                document.getElementById('yt-prev-btn')?.addEventListener('click', () => {
                    prevSong();
                });
                document.getElementById('yt-next-btn')?.addEventListener('click', () => {
                    nextSong();
                });
            });

            // Start initialization when DOM is ready
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', initialize);
            } else {
                initialize();
            }

            // ==========================================
            // Visitor Tracking / Real-time User Count
            // ==========================================
            const VISITOR_SESSION_KEY = 'dppd-visitor-session';
            const HEARTBEAT_INTERVAL = 30000; // 30 seconds
            let visitorSessionId = null;
            let heartbeatTimer = null;

            // Get or create session ID
            function getOrCreateSessionId() {
                let sessionId = sessionStorage.getItem(VISITOR_SESSION_KEY);
                if (!sessionId) {
                    sessionId = Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
                    sessionStorage.setItem(VISITOR_SESSION_KEY, sessionId);
                }
                return sessionId;
            }

            // Send heartbeat to server
            async function sendHeartbeat() {
                try {
                    const response = await fetch('/api/visitor-heartbeat', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ sessionId: visitorSessionId })
                    });
                    if (response.ok) {
                        const data = await response.json();
                        // Update session ID if server generated one
                        if (data.sessionId && !visitorSessionId) {
                            visitorSessionId = data.sessionId;
                            sessionStorage.setItem(VISITOR_SESSION_KEY, visitorSessionId);
                        }
                    }
                } catch (error) {
                    // Silently fail - don't disrupt user experience
                    console.debug('Heartbeat failed:', error);
                }
            }

            // Remove session when leaving
            async function removeSession() {
                if (visitorSessionId) {
                    // Use sendBeacon for reliable delivery on page unload
                    navigator.sendBeacon('/api/visitor-heartbeat', JSON.stringify({
                        sessionId: visitorSessionId,
                        action: 'leave'
                    }));
                }
            }

            // Initialize visitor tracking
            function initVisitorTracking() {
                visitorSessionId = getOrCreateSessionId();

                // Send initial heartbeat
                sendHeartbeat();

                // Set up regular heartbeat
                heartbeatTimer = setInterval(sendHeartbeat, HEARTBEAT_INTERVAL);

                // Handle page visibility changes
                document.addEventListener('visibilitychange', () => {
                    if (document.visibilityState === 'visible') {
                        // Page became visible - send heartbeat immediately
                        sendHeartbeat();
                        // Restart heartbeat timer
                        if (!heartbeatTimer) {
                            heartbeatTimer = setInterval(sendHeartbeat, HEARTBEAT_INTERVAL);
                        }
                    } else {
                        // Page hidden - clear timer but keep session
                        if (heartbeatTimer) {
                            clearInterval(heartbeatTimer);
                            heartbeatTimer = null;
                        }
                    }
                });

                // Try to remove session when page unloads
                window.addEventListener('beforeunload', removeSession);
            }

            // Start visitor tracking when DOM is ready
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', initVisitorTracking);
            } else {
                initVisitorTracking();
            }
        </script>

        <!-- YouTube Music Player -->
        <div id="youtube-music-player" class={`fixed bottom-4 right-4 z-50 backdrop-blur-sm rounded-2xl p-3 shadow-lg border-2 transition-all hover:scale-105 min-w-[200px] ${playerStyle.playerClass}`}>
            <div id="yt-song-title" class="text-white text-xs text-center mb-1 font-medium truncate px-2">
                {playerStyle.musicTitle}
            </div>
            <div id="yt-song-counter" class="text-white/60 text-[10px] text-center mb-2 hidden">1/1</div>
            <div class="flex items-center justify-center gap-2">
                <!-- Previous Button (hidden by default, shown when playlist exists) -->
                <button id="yt-prev-btn" class={`hidden items-center justify-center w-8 h-8 text-white transition-colors rounded-full ${playerStyle.buttonClass}`} aria-label="Previous song">
                    <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 24 24">
                        <path d="M6 6h2v12H6zm3.5 6l8.5 6V6z"></path>
                    </svg>
                </button>
                <button id="yt-music-toggle" class={`flex items-center justify-center w-10 h-10 text-white transition-colors rounded-full ${playerStyle.buttonClass}`} aria-label="Toggle music">
                    <svg id="yt-icon-play" class="w-6 h-6" fill="currentColor" viewBox="0 0 24 24">
                        <path d="M8 5v14l11-7z"></path>
                    </svg>
                    <svg id="yt-icon-pause" class="w-6 h-6 hidden" fill="currentColor" viewBox="0 0 24 24">
                        <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"></path>
                    </svg>
                </button>
                <!-- Next Button (hidden by default, shown when playlist exists) -->
                <button id="yt-next-btn" class={`hidden items-center justify-center w-8 h-8 text-white transition-colors rounded-full ${playerStyle.buttonClass}`} aria-label="Next song">
                    <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 24 24">
                        <path d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z"></path>
                    </svg>
                </button>
            </div>
        </div>

        <!-- Hidden YouTube iframe for audio -->
        <div id="youtube-player-container" class="hidden">
            <div id="youtube-player"></div>
        </div>

        <!-- Falling Effects Toggle Button (bottom left) - hidden for default theme since it has no effects -->
        <button id="effects-toggle" class={`fixed bottom-4 left-4 z-50 backdrop-blur-sm rounded-lg px-3 py-2 shadow-lg border-2 transition-all hover:scale-105 text-white text-xs font-medium ${playerStyle.playerClass} ${activeTheme === 'default' ? 'hidden' : ''}`}>
            <span id="effects-toggle-text">Hide Effects</span>
        </button>

        <div class="flex flex-col min-h-screen px-6 bg-noise sm:px-12">
            <div class="flex flex-col w-full max-w-5xl mx-auto grow">
                <Header />
                <main class="grow"><slot /></main>
                <Footer />
            </div>
        </div>

        {/* Admin inactivity timeout - only for admin pages (excluding login) */}
        {isAdmin && <AdminInactivityTimeout />}
    </body>
</html>
