---
import '../../src/styles/globals.css';
import '@fontsource-variable/inter/wght.css';
import interWoff2 from '@fontsource-variable/inter/files/inter-latin-wght-normal.woff2?url';
import Header from '../components/Header.astro';
import Footer from '../components/Footer.astro';
import { getStore } from '@netlify/blobs';

interface Props {
    title: string;
}

interface ThemeSettings {
    activeTheme: 'christmas' | 'halloween' | 'default' | 'new-year';
    christmasMusic: string;
    halloweenMusic: string;
    defaultMusic: string;
    newYearMusic: string;
}

const defaultThemeSettings: ThemeSettings = {
    activeTheme: 'new-year',
    christmasMusic: 'yXfWUNl1PbM',
    halloweenMusic: 'qw07ZfxeV4g',
    defaultMusic: '329iFlRszxs',
    newYearMusic: 'MmC4BLodWDk'
};

// Fetch theme settings from Netlify Blobs on the server
async function getThemeSettings(): Promise<ThemeSettings> {
    try {
        const store = getStore({ name: 'theme-settings', consistency: 'strong' });
        const data = await store.get('settings', { type: 'json' });
        if (data) {
            return data as ThemeSettings;
        }
        return defaultThemeSettings;
    } catch (error) {
        console.error('Error fetching theme settings:', error);
        return defaultThemeSettings;
    }
}

const { title } = Astro.props;

// Fetch theme settings server-side so everyone sees the same theme
const themeSettings = await getThemeSettings();
const activeTheme = themeSettings.activeTheme;
const bodyClass = `antialiased text-white theme-${activeTheme}`;

// Get the correct music ID for the active theme
const musicIds = {
    christmas: themeSettings.christmasMusic,
    halloween: themeSettings.halloweenMusic,
    default: themeSettings.defaultMusic,
    'new-year': themeSettings.newYearMusic || 'MmC4BLodWDk'
};
const activeMusicId = musicIds[activeTheme];

// Theme-specific styling for music player (server-rendered)
const themePlayerStyles = {
    christmas: {
        playerClass: 'bg-red-800/90 border-yellow-500',
        buttonClass: 'bg-green-700/50 hover:text-green-300',
        musicTitle: 'üéÑDel Perro PD - Christmas Music'
    },
    halloween: {
        playerClass: 'bg-purple-900/90 border-orange-500',
        buttonClass: 'bg-orange-700/50 hover:text-orange-300',
        musicTitle: 'üëª Del Perro PD - Spooky Music'
    },
    default: {
        playerClass: 'bg-blue-800/90 border-blue-400',
        buttonClass: 'bg-blue-700/50 hover:text-blue-300',
        musicTitle: 'üõ°Ô∏è Del Perro PD - Music'
    },
    'new-year': {
        playerClass: 'bg-black/90 border-yellow-400',
        buttonClass: 'bg-yellow-600/50 hover:text-yellow-300',
        musicTitle: 'üéÜ New Year 2026 Celebration'
    }
};
const playerStyle = themePlayerStyles[activeTheme];
---

<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <title>{title}</title>
        <meta name="viewport" content="width=device-width" />
        <meta name="generator" content={Astro.generator} />
        <link rel="icon" type="image/png" href="/images/DPPD_Seal_3.png" />
        <link rel="preload" as="font" type="font/woff2" href={interWoff2} crossorigin />
    </head>
    <body class={bodyClass} data-theme={activeTheme} data-music-id={activeMusicId}>
        <!-- Falling effects container -->
        <div id="effects-container" class="fixed inset-0 pointer-events-none z-[9999] overflow-hidden"></div>

        <!-- New Year Countdown Timer (only shown for new-year theme) -->
        <div id="countdown-container" class={`countdown-container ${activeTheme !== 'new-year' ? 'hidden' : ''}`}>
            <div id="countdown-title" class="countdown-title">üéÜ Countdown to 2026 üéÜ</div>
            <div id="countdown-timer" class="countdown-timer">
                <div class="countdown-unit">
                    <div id="countdown-days" class="countdown-value">00</div>
                    <div class="countdown-label">Days</div>
                </div>
                <div class="countdown-unit">
                    <div id="countdown-hours" class="countdown-value">00</div>
                    <div class="countdown-label">Hours</div>
                </div>
                <div class="countdown-unit">
                    <div id="countdown-minutes" class="countdown-value">00</div>
                    <div class="countdown-label">Minutes</div>
                </div>
                <div class="countdown-unit">
                    <div id="countdown-seconds" class="countdown-value">00</div>
                    <div class="countdown-label">Seconds</div>
                </div>
            </div>
        </div>

        <!-- Theme Effects Script - Uses server-provided theme -->
        <script>
            // Theme configuration
            const themeConfig = {
                christmas: {
                    class: 'theme-christmas',
                    musicTitle: 'üéÑDel Perro PD - Christmas Music',
                    playerStyle: 'bg-red-800/90 border-yellow-500',
                    buttonStyle: 'bg-green-700/50 hover:text-green-300',
                    symbols: ['‚ùÑ', '‚ùÖ', '‚ùÜ', '‚úª', '‚úº', '‚ùâ']
                },
                halloween: {
                    class: 'theme-halloween',
                    musicTitle: 'üëª Del Perro PD - Spooky Music',
                    playerStyle: 'bg-purple-900/90 border-orange-500',
                    buttonStyle: 'bg-orange-700/50 hover:text-orange-300',
                    symbols: ['üíÄ', 'üéÉ', 'üßü', 'üëª', 'ü¶á', 'üï∑Ô∏è']
                },
                default: {
                    class: 'theme-default',
                    musicTitle: 'üõ°Ô∏è Del Perro PD - Music',
                    playerStyle: 'bg-blue-800/90 border-blue-400',
                    buttonStyle: 'bg-blue-700/50 hover:text-blue-300',
                    symbols: []
                },
                'new-year': {
                    class: 'theme-new-year',
                    musicTitle: 'üéÜ New Year 2026 Celebration',
                    playerStyle: 'bg-black/90 border-yellow-400',
                    buttonStyle: 'bg-yellow-600/50 hover:text-yellow-300',
                    symbols: ['üéâ', 'üéä', '‚ú®', '‚≠ê', 'üåü', 'üí´'],
                    confetti: ['üéâ', 'üéä', 'ü•≥', 'üéá', 'üéÜ', '‚ú®', '‚≠ê', 'üíõ', 'üß°', 'üíú'],
                    years: ['2025', '2026']
                }
            };

            // Get theme from server-rendered data attribute (no API fetch needed)
            const currentTheme = document.body.dataset.theme || 'christmas';
            const musicId = document.body.dataset.musicId;
            let player = null;
            let isPlaying = false;
            let shouldStayPaused = false; // Flag to enforce paused state after seekTo

            // Storage key for music state persistence
            const MUSIC_STATE_KEY = 'dppd-music-state';

            // Track if user has ever interacted with music (to distinguish first visit from returning)
            const MUSIC_VISITED_KEY = 'dppd-music-visited';

            // Get saved music state from localStorage
            function getSavedMusicState() {
                try {
                    const saved = localStorage.getItem(MUSIC_STATE_KEY);
                    if (saved) {
                        const state = JSON.parse(saved);
                        // Only restore if the same music is playing (same theme)
                        if (state.musicId === musicId) {
                            return state;
                        }
                    }
                } catch (e) {
                    console.error('Error reading music state:', e);
                }
                return null;
            }

            // Check if user has visited before (to know if we should auto-play on first visit)
            function hasVisitedBefore() {
                return localStorage.getItem(MUSIC_VISITED_KEY) === 'true';
            }

            // Mark that user has visited
            function markAsVisited() {
                localStorage.setItem(MUSIC_VISITED_KEY, 'true');
            }

            // Save music state to localStorage
            function saveMusicState() {
                if (player && typeof player.getCurrentTime === 'function') {
                    try {
                        const state = {
                            musicId: musicId,
                            isPlaying: isPlaying,
                            currentTime: player.getCurrentTime(),
                            timestamp: Date.now()
                        };
                        localStorage.setItem(MUSIC_STATE_KEY, JSON.stringify(state));
                    } catch (e) {
                        console.error('Error saving music state:', e);
                    }
                }
            }

            // Save state before page unload (navigation)
            window.addEventListener('beforeunload', saveMusicState);
            // Also save periodically in case of unexpected closure
            setInterval(saveMusicState, 2000);

            // Apply theme styling to music player
            function applyThemeStyling() {
                const config = themeConfig[currentTheme] || themeConfig.christmas;

                // Update music player styling
                const musicPlayer = document.getElementById('youtube-music-player');
                if (musicPlayer) {
                    // Remove old style classes
                    musicPlayer.classList.remove(
                        'bg-red-800/90', 'border-yellow-500',
                        'bg-purple-900/90', 'border-orange-500',
                        'bg-blue-800/90', 'border-blue-400',
                        'bg-black/90', 'border-yellow-400'
                    );
                    // Add new style classes
                    config.playerStyle.split(' ').forEach(cls => musicPlayer.classList.add(cls));
                }

                const musicButton = document.getElementById('yt-music-toggle');
                if (musicButton) {
                    // Remove old button style classes
                    musicButton.classList.remove(
                        'bg-green-700/50', 'hover:text-green-300',
                        'bg-orange-700/50', 'hover:text-orange-300',
                        'bg-blue-700/50', 'hover:text-blue-300',
                        'bg-yellow-600/50', 'hover:text-yellow-300'
                    );
                    // Add new button style classes
                    config.buttonStyle.split(' ').forEach(cls => musicButton.classList.add(cls));
                }

                const musicTitle = document.getElementById('yt-song-title');
                if (musicTitle) {
                    musicTitle.textContent = config.musicTitle;
                }
            }

            // Create falling effects
            function createFallingEffects() {
                const container = document.getElementById('effects-container');
                if (!container) return;

                // Clear existing effects
                container.innerHTML = '';

                const config = themeConfig[currentTheme] || themeConfig.christmas;
                const symbols = config.symbols;

                if (symbols.length === 0) return; // No effects for default theme

                // Special handling for New Year theme
                if (currentTheme === 'new-year') {
                    createNewYearEffects(container, config);
                    return;
                }

                const numberOfElements = 50;

                for (let i = 0; i < numberOfElements; i++) {
                    setTimeout(() => {
                        createFallingElement(container, symbols);
                    }, i * 200);
                }
            }

            // Create New Year specific effects (confetti + years)
            function createNewYearEffects(container, config) {
                const confetti = config.confetti || [];
                const years = config.years || [];

                // Create confetti elements (more of them)
                for (let i = 0; i < 40; i++) {
                    setTimeout(() => {
                        createConfettiElement(container, confetti);
                    }, i * 150);
                }

                // Create year number elements
                for (let i = 0; i < 15; i++) {
                    setTimeout(() => {
                        createYearElement(container, years);
                    }, i * 400);
                }
            }

            // Create confetti element
            function createConfettiElement(container, confetti) {
                const element = document.createElement('div');
                element.className = 'falling-element falling-confetti';
                element.textContent = confetti[Math.floor(Math.random() * confetti.length)];

                // Random starting position
                element.style.left = Math.random() * 100 + 'vw';

                // Random size (smaller for confetti)
                const size = Math.random() * 1 + 0.8;
                element.style.fontSize = size + 'rem';

                // Random opacity
                element.style.opacity = (Math.random() * 0.4 + 0.6).toString();

                // Random animation duration (faster for confetti)
                const fallDuration = Math.random() * 8 + 6;
                const swayDuration = Math.random() * 2 + 1.5;
                element.style.animationDuration = fallDuration + 's, ' + swayDuration + 's';

                container.appendChild(element);

                // Remove and recreate when animation ends
                element.addEventListener('animationend', function() {
                    element.remove();
                    createConfettiElement(container, confetti);
                });
            }

            // Create year element (2025, 2026)
            function createYearElement(container, years) {
                const element = document.createElement('div');
                element.className = 'falling-element falling-year';
                element.textContent = years[Math.floor(Math.random() * years.length)];

                // Random starting position
                element.style.left = Math.random() * 100 + 'vw';

                // Larger size for year numbers
                const size = Math.random() * 1.5 + 1.5;
                element.style.fontSize = size + 'rem';

                // Random color - gold or silver
                const colors = ['#FFD700', '#C0C0C0', '#FFA500', '#FFE555'];
                element.style.color = colors[Math.floor(Math.random() * colors.length)];

                // Higher opacity for years
                element.style.opacity = (Math.random() * 0.3 + 0.7).toString();

                // Slower animation for years
                const fallDuration = Math.random() * 12 + 10;
                const swayDuration = Math.random() * 4 + 3;
                element.style.animationDuration = fallDuration + 's, ' + swayDuration + 's';

                container.appendChild(element);

                // Remove and recreate when animation ends
                element.addEventListener('animationend', function() {
                    element.remove();
                    createYearElement(container, years);
                });
            }

            function createFallingElement(container, symbols) {
                const element = document.createElement('div');
                element.className = 'falling-element';
                element.textContent = symbols[Math.floor(Math.random() * symbols.length)];

                // Random starting position
                element.style.left = Math.random() * 100 + 'vw';

                // Random size
                const size = Math.random() * 1.5 + 0.5;
                element.style.fontSize = size + 'rem';

                // Random opacity
                element.style.opacity = (Math.random() * 0.5 + 0.5).toString();

                // Random animation duration
                const fallDuration = Math.random() * 10 + 8;
                const swayDuration = Math.random() * 3 + 2;
                element.style.animationDuration = fallDuration + 's, ' + swayDuration + 's';

                container.appendChild(element);

                // Remove and recreate when animation ends
                element.addEventListener('animationend', function() {
                    element.remove();
                    createFallingElement(container, symbols);
                });
            }

            // Initialize YouTube player
            function initYouTubePlayer(videoId) {
                if (typeof YT === 'undefined' || typeof YT.Player === 'undefined') {
                    // Wait for API to load
                    setTimeout(() => initYouTubePlayer(videoId), 100);
                    return;
                }

                // Get saved state to restore playback position
                const savedState = getSavedMusicState();

                player = new YT.Player('youtube-player', {
                    height: '0',
                    width: '0',
                    videoId: videoId,
                    playerVars: {
                        'autoplay': 0,
                        'controls': 0,
                        'loop': 1,
                        'playlist': videoId
                    },
                    events: {
                        'onReady': function(event) {
                            player.setVolume(30);

                            // Mark that user has visited the site
                            markAsVisited();

                            // Restore playback position and state if available
                            if (savedState) {
                                // Seek to saved position (account for small time drift)
                                const timeSinceLastSave = (Date.now() - savedState.timestamp) / 1000;
                                let seekTime = savedState.currentTime + timeSinceLastSave;

                                // Get video duration to handle looping
                                const duration = player.getDuration();
                                if (duration > 0) {
                                    seekTime = seekTime % duration; // Handle wrap-around for looping
                                }

                                // Only play if it was playing before navigation
                                if (savedState.isPlaying) {
                                    player.seekTo(seekTime, true);
                                    player.playVideo();
                                } else {
                                    // Music was paused - keep it paused
                                    // Set internal state and update UI immediately
                                    isPlaying = false;
                                    shouldStayPaused = true; // Flag to prevent auto-play from seekTo
                                    updatePlayIcon();
                                    // Seek to position - if it triggers play, onStateChange will pause it
                                    player.seekTo(seekTime, true);
                                    // Also explicitly pause as a fallback
                                    player.pauseVideo();
                                }
                            } else if (!hasVisitedBefore()) {
                                // First visit ever - start playing automatically
                                player.playVideo();
                            } else {
                                // Returning visitor with no saved state (theme changed) - start playing
                                player.playVideo();
                            }
                        },
                        'onStateChange': function(event) {
                            // If we should stay paused but YouTube started playing (from seekTo), pause it again
                            if (shouldStayPaused && event.data === YT.PlayerState.PLAYING) {
                                player.pauseVideo();
                                shouldStayPaused = false; // Only enforce once
                                return;
                            }

                            if (event.data === YT.PlayerState.PLAYING) {
                                isPlaying = true;
                                updatePlayIcon();
                            } else if (event.data === YT.PlayerState.PAUSED || event.data === YT.PlayerState.ENDED) {
                                isPlaying = false;
                                updatePlayIcon();
                            }
                        }
                    }
                });
            }

            function updatePlayIcon() {
                const playIcon = document.getElementById('yt-icon-play');
                const pauseIcon = document.getElementById('yt-icon-pause');
                if (isPlaying) {
                    playIcon?.classList.add('hidden');
                    pauseIcon?.classList.remove('hidden');
                } else {
                    playIcon?.classList.remove('hidden');
                    pauseIcon?.classList.add('hidden');
                }
            }

            // Initialize everything (theme is already applied server-side)
            function initialize() {
                // Apply theme styling to music player elements
                applyThemeStyling();

                // Start falling effects with the server-provided theme
                createFallingEffects();

                // Initialize countdown for New Year theme
                if (currentTheme === 'new-year') {
                    initCountdown();
                }

                // Initialize YouTube player with the server-provided music ID
                initYouTubePlayer(musicId);
            }

            // New Year Countdown Timer
            function initCountdown() {
                const countdownContainer = document.getElementById('countdown-container');
                if (!countdownContainer) return;

                countdownContainer.classList.remove('hidden');

                function updateCountdown() {
                    // Target: January 1, 2026, 00:00:00 CST (UTC-6)
                    const now = new Date();
                    const targetDate = new Date('2026-01-01T00:00:00-06:00');
                    const diff = targetDate - now;

                    if (diff <= 0) {
                        // It's New Year!
                        document.getElementById('countdown-title').textContent = 'üéâ HAPPY NEW YEAR 2026! üéâ';
                        document.getElementById('countdown-timer').innerHTML = '<div class="text-4xl text-yellow-400 font-bold animate-pulse">üéÜ Welcome to 2026! üéÜ</div>';
                        return;
                    }

                    const days = Math.floor(diff / (1000 * 60 * 60 * 24));
                    const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
                    const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
                    const seconds = Math.floor((diff % (1000 * 60)) / 1000);

                    document.getElementById('countdown-days').textContent = days.toString().padStart(2, '0');
                    document.getElementById('countdown-hours').textContent = hours.toString().padStart(2, '0');
                    document.getElementById('countdown-minutes').textContent = minutes.toString().padStart(2, '0');
                    document.getElementById('countdown-seconds').textContent = seconds.toString().padStart(2, '0');
                }

                // Update immediately and then every second
                updateCountdown();
                setInterval(updateCountdown, 1000);
            }

            // Load YouTube IFrame API
            const tag = document.createElement('script');
            tag.src = "https://www.youtube.com/iframe_api";
            const firstScriptTag = document.getElementsByTagName('script')[0];
            firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

            // Set up music toggle button
            document.addEventListener('DOMContentLoaded', function() {
                document.getElementById('yt-music-toggle')?.addEventListener('click', () => {
                    if (player) {
                        if (isPlaying) {
                            player.pauseVideo();
                        } else {
                            player.playVideo();
                        }
                    }
                });
            });

            // Start initialization when DOM is ready
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', initialize);
            } else {
                initialize();
            }
        </script>

        <!-- YouTube Music Player -->
        <div id="youtube-music-player" class={`fixed bottom-4 right-4 z-50 backdrop-blur-sm rounded-2xl p-3 shadow-lg border-2 transition-all hover:scale-105 min-w-[200px] ${playerStyle.playerClass}`}>
            <div id="yt-song-title" class="text-white text-xs text-center mb-2 font-medium truncate px-2">
                {playerStyle.musicTitle}
            </div>
            <div class="flex items-center justify-center gap-2">
                <button id="yt-music-toggle" class={`flex items-center justify-center w-10 h-10 text-white transition-colors rounded-full ${playerStyle.buttonClass}`} aria-label="Toggle music">
                    <svg id="yt-icon-play" class="w-6 h-6" fill="currentColor" viewBox="0 0 24 24">
                        <path d="M8 5v14l11-7z"></path>
                    </svg>
                    <svg id="yt-icon-pause" class="w-6 h-6 hidden" fill="currentColor" viewBox="0 0 24 24">
                        <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"></path>
                    </svg>
                </button>
            </div>
        </div>

        <!-- Hidden YouTube iframe for audio -->
        <div id="youtube-player-container" class="hidden">
            <div id="youtube-player"></div>
        </div>

        <div class="flex flex-col min-h-screen px-6 bg-noise sm:px-12">
            <div class="flex flex-col w-full max-w-5xl mx-auto grow">
                <Header />
                <main class="grow"><slot /></main>
                <Footer />
            </div>
        </div>
    </body>
</html>
